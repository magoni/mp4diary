<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diary.mp4</title>
    <link rel="icon" href="/favicon.ico" />
    <style>
        body {
            background: #fff;
            padding: 16px;
        }

        p {
            margin-top: 0;
        }

        #language-select {
            margin-bottom: 16px;
        }

        .description,
        #language-select {
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
                sans-serif;
            font-size: 16px;
            line-height: 1.5;
            color: #222;
        }

        .description-spacer {
            display: none;
        }

        /* larger screens */
        @media screen and (min-width: 600px) {
            body {
                position: relative;
                overflow: hidden;
            }

            .description-spacer {
                display: block;
            }

            .description-container {
                position: fixed;
                right: 16px;
                top: 16px;
                max-width: 500px;
                margin: 0 auto 48px auto;
                padding: 0 16px;
                z-index: 3;
                text-align: right;
            }

            .description {
                pointer-events: none;
            }

            video {
                position: absolute;
                width: 300px;
            }

            /* animated background */
            #bg-container {
                position: fixed;
                inset: 0;
                pointer-events: none;
                z-index: 0;
                overflow: hidden;
            }

            .bg {
                position: absolute;
                border-radius: 50%;
                /* darker particles use a slightly tighter blur */
                filter: blur(6px);
                transform: translate3d(0, 0, 0);
                /* fallback/base opacity for non-JS or initial paint */
                opacity: 1.0;
                /* on white background a multiply blend gives dark glows */
                mix-blend-mode: multiply;
                will-change: transform, opacity;
            }

            /* image layer container */
            #image-layer {
                position: fixed;
                inset: 0;
                z-index: 2;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 1fr;
                grid-auto-rows: 1fr 1fr;
                gap: 36px;
                align-items: center;
                justify-items: center;
                padding: 36px;
                box-sizing: border-box;
            }

            /* make each grid cell clip overflow and allow images to fill the full cell height */
            .image-item {
                overflow: hidden;
                width: 100%;
                height: 100%;
            }

            /* images: prefer filling the full cell height and let width size automatically */
            .image-item img {
                display: block;
                height: 100%;
                width: auto;
                max-width: none;
                object-fit: cover;
                /* safety in case some images still use width/height */
                margin: 0 auto;
            }

            @media (hover: hover) {

                /* mask applied to the grid cell container — child image content will be revealed inside the circular mask */
                .image-item.masked {
                    -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
                    mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
                    -webkit-mask-repeat: no-repeat;
                    mask-repeat: no-repeat;
                    transition: -webkit-mask-position 120ms linear, mask-position 120ms linear;
                }

                /* allow the image inside a cell to slide around inside the cell — offsets are stored on the image itself */
                .image-item img {
                    position: relative;
                    transform: translate(var(--ox, 0px), var(--oy, 0px));
                    transition: transform 220ms ease, -webkit-mask-position 120ms linear, mask-position 120ms linear;
                }

                /* helper: when a cell is hidden (not under cursor), push the center off-screen so it becomes invisible */
                .image-item.hidden {
                    -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
                    mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
                }

                /* pulse to hint presence — temporarily reveal the center and scale briefly */
                /* pulse animation applies to the image element so it scales inside the cell */
                img.pulse {
                    animation: pulseReveal var(--pulse-duration, 1.2s) ease-in-out both;
                }

                @keyframes pulseReveal {
                    0% {
                        transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(0.95);
                        opacity: 0.0;
                    }

                    15% {
                        opacity: 1.0;
                        transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.03);
                    }

                    50% {
                        transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.06);
                    }

                    85% {
                        opacity: 0.96;
                        transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.02);
                    }

                    100% {
                        transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.0);
                        opacity: 0.0;
                    }
                }
            }
        }
    </style>
</head>

<body bgcolor="#ffffff">
    <div id="bg-container" aria-hidden="true"></div>

    <div class="description-container">
        <select id="language-select" onchange="
        {
            const enDesc = document.getElementById('en');
            const frDesc = document.getElementById('fr');
            if(this.value==='en'){
                enDesc.style.display='block';
                frDesc.style.display='none';
            } else if(this.value==='fr'){
                enDesc.style.display='none';
                frDesc.style.display='block';
            }
        }">
            <option value="en" selected>English</option>
            <option value="fr">Français</option>
        </select>
        <div class="description" id="en">
            <p>with <strong>diary.mp4</strong>, o0yu (Yuki) and gonima (Evan Magoni) shift the format of collaborative
                audiovisual performance from a live event to a diaryｰlike experience. a change in pace, space and focus,
                towards non-linear forms and a cozier process.</p>
            <p>the artists met over a warm meal and spent one week as virtual pen pals, sending a single evolving clip
                back and forth, to create seven short diary entries.</p>
            <p>for the installation, a low table on a rug and cushions lower the viewer's gaze and pace.</p>
            <p>the creation process lead to variations and branches, open pages of a slice-of-dream chapter.</p>
            <!-- TODO change text based on input device -->
            <p>please <strong>explore by moving the mouse</strong> and clicking to open the videos, and come back any
                time:
                <em>mp4diary.neocities.org</em> :)
            </p>
        </div>
        <div class="description" id="fr" style="display:none;">
            <p>avec <strong>diary.mp4</strong>, o0yu (Yuki) et gonima (Evan Magoni) transforment le format de la
                performance
                audiovisuelle
                collaborative, passant d'un événement en direct à une expérience semblable à un journal intime. un
                changement de rythme, d'espace et d'orientation, vers des formes non linéaires et un processus plus
                intimiste.</p>
            <p>les artistes se sont rencontrés autour d'un repas chaleureux et ont passé une semaine à échanger des
                messages
                virtuels, s'envoyant un seul clip évolutif, afin de créer sept courtes entrées de journal intime.</p>
            <p>pour l'installation, une table basse sur un tapis, deux coussins et deux écouteurs connectés à un
                ordinateur portable invitent
                le
                spectateur à baisser le regard et à ralentir le rythme.</p>
            <p>le processus de création n'a pas abouti à un produit final ou à une performance unique, mais plutôt à des
                variations et des ramifications, des pages ouvertes d'un chapitre de rêve.</p>
            <!-- TODO change text based on input device -->
            <p><strong>explorez en déplaçant la souris</strong> et en cliquant pour ouvrir les vidéos, et revenez quand
                vous le souhaitez
                : <em>mp4diary.neocities.org</em> :)</p>
        </div>
    </div>

    <!-- TODO default to smaller videos, only load larger if screen height > 480 + some buffer -->
    <!-- TODO actual video elements on mobile? only replace on desktop -->
    <div id="image-layer">
        <div class="image-item">
            <img src="./static/day1.jpg" data-video="./static/day1.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item">
            <img src="./static/day2.jpg" data-video="./static/day2.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item">
            <img src="./static/day3.jpg" data-video="./static/day3.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item description-spacer"><!-- description placeholder -->&nbsp;</div>
        <div class="image-item">
            <img src="./static/day4.jpg" data-video="./static/day4.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item">
            <img src="./static/day5.jpg" data-video="./static/day5.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item">
            <img src="./static/day6.jpg" data-video="./static/day6.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
        <div class="image-item">
            <img src="./static/day7.jpg" data-video="./static/day7.mov"
                style="height:100%;width:auto;cursor:pointer;" />
        </div>
    </div>

    <script>
        // remember if the user interacted with the page — allows unmuted autoplay later
        window._userHasInteracted = window._userHasInteracted || false;
        (function () {
            function mark() {
                if (window._userHasInteracted) return;
                window._userHasInteracted = true;
                // remove listeners once we have an interaction
                document.removeEventListener('pointerdown', mark);
                document.removeEventListener('keydown', mark);
                document.removeEventListener('touchstart', mark);
            }

            // capture a broad user gesture set
            document.addEventListener('pointerdown', mark, { once: true });
            document.addEventListener('keydown', mark, { once: true });
            document.addEventListener('touchstart', mark, { once: true });
        })();
    </script>

    <!-- TODO only load the below for more powerful devices -->
    <script src="./static/particles.min.js" defer></script>
    <!-- TODO only load the below for desktop -->
    <script src="./static/bg.js" defer></script>

    <script>
        // Open a centered popup window and write a simple HTML document with an autoplaying, muted video
        function openCenteredPopup(url, desiredWidth = 960, desiredHeight = 604) {
            if (!url) return null;

            // calculate the size within available screen
            const w = Math.min(desiredWidth, Math.floor(window.screen.availWidth * 0.92));
            const h = Math.min(desiredHeight, Math.floor(window.screen.availHeight * 0.86));

            // account for multi-screen setups
            const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
            const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;

            const left = dualScreenLeft + Math.floor((window.innerWidth - w) / 2);
            const top = dualScreenTop + Math.floor((window.innerHeight - h) / 2);

            // include 'location=no' (old browsers) and remove toolbar/status where possible.
            // NOTE: modern browsers intentionally keep an address bar for security —
            // this is a best-effort request and may be ignored.
            const features = 'width=' + w + ',height=' + h + ',left=' + left + ',top=' + top + ',resizable=yes,scrollbars=no,location=no,status=no,toolbar=no,menubar=no';

            // open or reuse a named popup window so repeated clicks reuse the same popup
            // (some browsers still show the address bar regardless)
            const win = window.open('', 'video-popup', features);
            if (!win) {
                // popup blocked — fallback to opening video in a new tab
                window.location.href = url;
                return null;
            }

            // Basic markup for the popup — if the user has previously interacted with the page
            // we will try to open unmuted, otherwise start muted to satisfy autoplay policies.
            const shouldStartUnmuted = !!window._userHasInteracted;

            // Basic markup for the popup
            const html = '<!doctype html>' +
                '<html>' +
                '<head>' +
                '<meta charset="utf-8">' +
                '<meta name="viewport" content="width=device-width,initial-scale=1">' +
                '<title>Video</title>' +
                '<style>html,body{height:100%;margin:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center}video{max-width:100%;max-height:100%;box-shadow:0 8px 40px rgba(0,0,0,0.5);}</style>' +
                '</head>' +
                '<body>' +
                '<video id="popupVideo" src="' + url + '" playsinline autoplay ' + (shouldStartUnmuted ? '' : 'muted') + ' controls></video>' +
                '<script>var v=document.getElementById("popupVideo"); if(' + (shouldStartUnmuted ? 'true' : 'false') + '){ v.muted = false; } else { v.muted = true; } v.play && v.play().catch(function(){}); window.addEventListener("beforeunload", function(){ try{v.pause(); }catch(e){} });<\/script>' +
                '</body>' +
                '</html>';

            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
                win.focus();
            } catch (err) {
                // Could fail on cross-origin or other restrictions — fallback
                console.warn('Could not write to popup window — opening raw video URL instead', err);
                win.location.href = url;
            }

            return win;
        }

        // If we're hosted on a neocities domain, hotlink videos from the public netlify site
        (function () {
            try {
                const host = window.location.hostname || '';
                if (host.indexOf('neocities') !== -1) {
                    const base = 'https://mp4diary.netlify.app/';
                    document.querySelectorAll('img[data-video]').forEach(img => {
                        const v = img.getAttribute('data-video') || '';
                        // leave absolute URLs alone
                        if (!v || /^https?:\/\//i.test(v)) return;
                        // normalize relative path and hotlink to the netlify host
                        const normalized = v.replace(/^\.\//, '').replace(/^\//, '');
                        const finalUrl = base + normalized;
                        img.setAttribute('data-video', finalUrl);
                        // ensure dataset reflects change immediately
                        img.dataset.video = finalUrl;
                    });
                }
            } catch (err) {
            }
        })();

        // Attach click handlers to images with data-video set
        document.addEventListener('click', function (e) {
            const el = e.target && e.target.closest && e.target.closest('img[data-video]');
            if (!el) return;
            e.preventDefault();
            const videoUrl = el.dataset && el.dataset.video;
            // open popup at desired, fixed size: 960x604 (still constrained by available screen)
            openCenteredPopup(videoUrl, 960, 604);
        }, { capture: true });
    </script>

    <!-- TODO only load the below on desktop -->
    <script>
        (function () {
            window.FlashlightConfig = window.FlashlightConfig || { radius: 260, enabled: true };

            const container = document.getElementById('image-layer');
            if (!container) return;

            // treat each grid cell (.image-item) as a masked cell — child images move inside
            const items = Array.from(container.querySelectorAll('.image-item'));
            items.forEach(item => {
                const img = item.querySelector && item.querySelector('img');
                if (!img) return; // skip non-image cells (eg description)

                // apply mask state to the cell; image offsets live on the image
                item.classList.add('masked');
                // start hidden until user moves over the cell
                item.classList.add('hidden');
                item.style.setProperty('--fr', window.FlashlightConfig.radius + 'px');

                // assign a small random offset for the inner image so the grid looks staggered
                const ox = Math.round((Math.random() - 0.5) * 80); // -40..40
                const oy = Math.round((Math.random() - 0.5) * 60); // -30..30
                img.style.setProperty('--ox', ox + 'px');
                img.style.setProperty('--oy', oy + 'px');
            });

            // pulsing discovery: occasionally reveal a hidden masked image to hint presence
            window.FlashlightPulseConfig = window.FlashlightPulseConfig || { enabled: true, minDelay: 3000, maxDelay: 9000, duration: 5000 };

            let pulseTimer = null;

            function pickRandomHiddenImage() {
                const hidden = items.filter(i => i.classList.contains('hidden') && i.querySelector('img'));
                if (!hidden.length) return null;
                // prefer images not pulsed recently
                const idx = Math.floor(Math.random() * hidden.length);
                return hidden[idx];
            }

            function pulseImage(item) {
                if (!item) return;
                // skip pulsing if the user is currently hovering this cell — don't interfere
                try {
                    if (item.matches && item.matches(':hover')) return;
                } catch (_) { }

                const img = item.querySelector && item.querySelector('img');
                if (!img) return;

                // center the pulse at the cell center
                const rect = item.getBoundingClientRect();
                const cx = Math.round(rect.width / 2);
                const cy = Math.round(rect.height / 2);
                item.style.setProperty('--fx', cx + 'px');
                item.style.setProperty('--fy', cy + 'px');

                // show briefly
                item.classList.remove('hidden');
                img.classList.add('pulse');

                // remove pulse state after duration
                setTimeout(() => {
                    img.classList.remove('pulse');
                    // only hide again if still enabled and NOT hovered — avoid racing with pointer
                    try {
                        if (window.FlashlightConfig && window.FlashlightConfig.enabled && !(item.matches && item.matches(':hover'))) {
                            item.classList.add('hidden');
                        }
                    } catch (_) {
                        if (window.FlashlightConfig && window.FlashlightConfig.enabled) item.classList.add('hidden');
                    }
                }, window.FlashlightPulseConfig.duration || 1000);
            }

            function scheduleNextPulse() {
                if (!window.FlashlightPulseConfig.enabled) return;
                const delay = window.FlashlightPulseConfig.minDelay + Math.random() * (window.FlashlightPulseConfig.maxDelay - window.FlashlightPulseConfig.minDelay);
                pulseTimer = setTimeout(() => {
                    const img = pickRandomHiddenImage();
                    if (img) pulseImage(img);
                    scheduleNextPulse();
                }, delay);
            }

            // start pulsing loop
            if (window.FlashlightPulseConfig.enabled) scheduleNextPulse();

            function setRadius(r) {
                items.forEach(i => i.style.setProperty('--fr', r + 'px'));
            }

            function enable() {
                window.FlashlightConfig.enabled = true;
                // keep them hidden until pointer moves into a cell
                items.forEach(i => i.classList.add('hidden'));
            }

            function disable() {
                window.FlashlightConfig.enabled = false;
                // remove masking so cells display normally
                items.forEach(i => {
                    i.classList.remove('masked', 'hidden');
                    const child = i.querySelector && i.querySelector('img');
                    if (child) child.classList.remove('pulse');
                });
            }


            // Throttle pointer/touch handling by batching events and processing via requestAnimationFrame
            let rafScheduled = false;
            let pendingPos = { x: 0, y: 0 };

            function scheduleProcess(clientX, clientY) {
                pendingPos.x = clientX;
                pendingPos.y = clientY;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        rafScheduled = false;
                        processPosition(pendingPos.x, pendingPos.y);
                    });
                }
            }

            function onPointerMove(e) {
                if (!window.FlashlightConfig.enabled) return;
                scheduleProcess(e.clientX, e.clientY);
            }

            function onTouchMove(e) {
                const t = e.touches && e.touches[0];
                if (!t || !window.FlashlightConfig.enabled) return;
                scheduleProcess(t.clientX, t.clientY);
            }

            function processPosition(clientX, clientY) {
                // update each image based on the latest batched cursor position
                for (const item of items) {
                    const r = item.getBoundingClientRect();
                    const inside = clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
                    if (inside) {
                        const cx = Math.round(clientX - r.left);
                        const cy = Math.round(clientY - r.top);
                        item.classList.remove('hidden');
                        item.style.setProperty('--fx', cx + 'px');
                        item.style.setProperty('--fy', cy + 'px');
                    } else {
                        item.classList.add('hidden');
                    }
                }
            }

            // wire events
            document.addEventListener('pointermove', onPointerMove, { passive: true });
            document.addEventListener('touchmove', onTouchMove, { passive: true });

            // keyboard toggle: 'f' toggles flashlight
            document.addEventListener('keydown', (e) => {
                if (e.key === 'f' || e.key === 'F') {
                    if (window.FlashlightConfig.enabled) disable(); else enable();
                }
            });

            // expose API
            window.Flashlight = { enable, disable, setRadius };
        })();
    </script>
</body>

</html>