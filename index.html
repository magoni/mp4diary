<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diary.mp4</title>
    <style>
        body {
            position: relative;
            background: #fff;
            overflow: hidden;
        }

        video {
            position: absolute;
            width: 300px;
        }

        /* halo background */
        #halo-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .halo {
            position: absolute;
            border-radius: 50%;
            /* darker particles use a slightly tighter blur */
            filter: blur(6px);
            transform: translate3d(0, 0, 0);
            /* fallback/base opacity for non-JS or initial paint */
            opacity: 1.0;
            /* on white background a multiply blend gives dark glows */
            mix-blend-mode: multiply;
            will-change: transform, opacity;
        }

        /* image layer container */
        #image-layer {
            position: fixed;
            inset: 0;
            z-index: 2;
        }

        /* per-image mask: hide image except for a circular, centered area at --fx/--fy */
        img.masked {
            -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            transition: -webkit-mask-position 120ms linear, mask-position 120ms linear;
        }

        /* helper: when an image is hidden (not under cursor), push the center off-screen so it becomes invisible */
        img.masked.hidden {
            -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
        }
    </style>
</head>

<body bgcolor="#ffffff">
    <div id="halo-container" aria-hidden="true"></div>

    <div id="image-layer" style="position:fixed;inset:0;z-index:2;">
        <img src="./static/day1.jpg" data-video="./static/day1.mov"
            style="position: relative; top: 50px; left: 50px; width: 400px; cursor: pointer;">
        <img src="./static/day2.jpg" data-video="./static/day2.mov"
            style="position: relative; top: 350px; left: 400px; width: 400px; cursor: pointer;">
        <img src="./static/day3.jpg" data-video="./static/day3.mov"
            style="position: relative; top: 550px; left: 600px; width: 400px; cursor: pointer;">
        <img src="./static/day4.jpg" data-video="./static/day4.mov"
            style="position: relative; top: 650px; left: 50px; width: 400px; cursor: pointer;">
        <img src="./static/day5.jpg" data-video="./static/day5.mov"
            style="position: relative; top: 650px; left: 50px; width: 400px; cursor: pointer;">
        <img src="./static/day6.jpg" data-video="./static/day6.mov"
            style="position: relative; top: 650px; left: 50px; width: 400px; cursor: pointer;">
        <img src="./static/day7.jpg" data-video="./static/day7.mov"
            style="position: relative; top: 650px; left: 50px; width: 400px; cursor: pointer;">
    </div>

    <script>
        // remember if the user interacted with the page — allows unmuted autoplay later
        window._userHasInteracted = window._userHasInteracted || false;
        (function () {
            function mark() {
                if (window._userHasInteracted) return;
                window._userHasInteracted = true;
                // remove listeners once we have an interaction
                document.removeEventListener('pointerdown', mark);
                document.removeEventListener('keydown', mark);
                document.removeEventListener('touchstart', mark);
            }

            // capture a broad user gesture set
            document.addEventListener('pointerdown', mark, { once: true });
            document.addEventListener('keydown', mark, { once: true });
            document.addEventListener('touchstart', mark, { once: true });
        })();
        window.HaloBackgroundConfig = window.HaloBackgroundConfig || {
            count: 120,
            colors: [
                'rgba(12, 12, 12, 0.95)',
                'rgba(36, 36, 36, 0.95)',
                'rgba(64, 64, 64, 0.95)',
                'rgba(16, 20, 24, 0.95)'
            ],
            sizeMin: 6,
            sizeMax: 36,
            blur: 6
        };
    </script>
    <script src="./static/halo.js" defer></script>

    <script>
        // Open a centered popup window and write a simple HTML document with an autoplaying, muted video
        function openCenteredPopup(url, desiredWidth = 960, desiredHeight = 604) {
            if (!url) return null;

            // calculate the size within available screen
            const w = Math.min(desiredWidth, Math.floor(window.screen.availWidth * 0.92));
            const h = Math.min(desiredHeight, Math.floor(window.screen.availHeight * 0.86));

            // account for multi-screen setups
            const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
            const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;

            const left = dualScreenLeft + Math.floor((window.innerWidth - w) / 2);
            const top = dualScreenTop + Math.floor((window.innerHeight - h) / 2);

            // include 'location=no' (old browsers) and remove toolbar/status where possible.
            // NOTE: modern browsers intentionally keep an address bar for security —
            // this is a best-effort request and may be ignored.
            const features = 'width=' + w + ',height=' + h + ',left=' + left + ',top=' + top + ',resizable=yes,scrollbars=no,location=no,status=no,toolbar=no,menubar=no';

            // open or reuse a named popup window so repeated clicks reuse the same popup
            // (some browsers still show the address bar regardless)
            const win = window.open('', 'video-popup', features);
            if (!win) {
                // popup blocked — fallback to opening video in a new tab
                window.location.href = url;
                return null;
            }

            // Basic markup for the popup — if the user has previously interacted with the page
            // we will try to open unmuted, otherwise start muted to satisfy autoplay policies.
            const shouldStartUnmuted = !!window._userHasInteracted;

            // Basic markup for the popup
            const html = '<!doctype html>' +
                '<html>' +
                '<head>' +
                '<meta charset="utf-8">' +
                '<meta name="viewport" content="width=device-width,initial-scale=1">' +
                '<title>Video</title>' +
                '<style>html,body{height:100%;margin:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center}video{max-width:100%;max-height:100%;box-shadow:0 8px 40px rgba(0,0,0,0.5);}</style>' +
                '</head>' +
                '<body>' +
                '<video id="popupVideo" src="' + url + '" playsinline autoplay ' + (shouldStartUnmuted ? '' : 'muted') + ' controls></video>' +
                '<script>var v=document.getElementById("popupVideo"); if(' + (shouldStartUnmuted ? 'true' : 'false') + '){ v.muted = false; } else { v.muted = true; } v.play && v.play().catch(function(){}); window.addEventListener("beforeunload", function(){ try{v.pause(); }catch(e){} });<\/script>' +
                '</body>' +
                '</html>';

            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
                win.focus();
            } catch (err) {
                // Could fail on cross-origin or other restrictions — fallback
                console.warn('Could not write to popup window — opening raw video URL instead', err);
                win.location.href = url;
            }

            return win;
        }

        // Attach click handlers to images with data-video set
        document.addEventListener('click', function (e) {
            const el = e.target && e.target.closest && e.target.closest('img[data-video]');
            if (!el) return;
            e.preventDefault();
            const videoUrl = el.dataset && el.dataset.video;
            // open popup at desired, fixed size: 960x604 (still constrained by available screen)
            openCenteredPopup(videoUrl, 960, 604);
        }, { capture: true });
    </script>

    <script>
        (function () {
            // small runtime config (can be changed on window for customization)
            window.FlashlightConfig = window.FlashlightConfig || { radius: 260, enabled: true };

            const container = document.getElementById('image-layer');
            if (!container) return;

            // all images in the image-layer are masked
            const images = Array.from(container.querySelectorAll('img'));
            images.forEach(img => {
                img.classList.add('masked');
                // start hidden until user moves over an image (keeps the same UX as the fullscreen flashlight)
                img.classList.add('hidden');
                img.style.setProperty('--fr', window.FlashlightConfig.radius + 'px');
            });

            function setRadius(r) {
                images.forEach(i => i.style.setProperty('--fr', r + 'px'));
            }

            function enable() {
                window.FlashlightConfig.enabled = true;
                // keep them hidden until pointer moves into an image
                images.forEach(i => i.classList.add('hidden'));
            }

            function disable() {
                window.FlashlightConfig.enabled = false;
                // remove masking so images display normally
                images.forEach(i => i.classList.remove('masked', 'hidden'));
            }

            // track pointer and update each image's local mask if pointer sits inside its bounds
            function onPointerMove(e) {
                if (!window.FlashlightConfig.enabled) return;
                for (const img of images) {
                    const r = img.getBoundingClientRect();
                    const inside = e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom;
                    if (inside) {
                        const cx = Math.round(e.clientX - r.left);
                        const cy = Math.round(e.clientY - r.top);
                        img.classList.remove('hidden');
                        img.style.setProperty('--fx', cx + 'px');
                        img.style.setProperty('--fy', cy + 'px');
                    } else {
                        // push mask off-screen so image is hidden
                        img.classList.add('hidden');
                    }
                }
            }

            function onTouchMove(e) {
                const t = e.touches && e.touches[0];
                if (!t) return;
                onPointerMove(t);
            }

            // wire events
            document.addEventListener('pointermove', onPointerMove, { passive: true });
            document.addEventListener('touchmove', onTouchMove, { passive: true });

            // keyboard toggle: 'f' toggles flashlight
            document.addEventListener('keydown', (e) => {
                if (e.key === 'f' || e.key === 'F') {
                    if (window.FlashlightConfig.enabled) disable(); else enable();
                }
            });

            // expose API
            window.Flashlight = { enable, disable, setRadius };
        })();
    </script>
</body>

</html>