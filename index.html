<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diary.mp4</title>
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="./static/style.css" />
</head>

<body bgcolor="#ffffff">
    <div id="bg-container" aria-hidden="true"></div>

    <div class="description-container">
        <select id="language-select" onchange="
        {
            const enDesc = document.getElementById('en');
            const frDesc = document.getElementById('fr');
            if(this.value==='en'){
                enDesc.style.display='block';
                frDesc.style.display='none';
            } else if(this.value==='fr'){
                enDesc.style.display='none';
                frDesc.style.display='block';
            }
        }">
            <option value="en" selected>English</option>
            <option value="fr">Français</option>
        </select>
        <div class="description" id="en">
            <p><strong>diary.mp4</strong> shifts the format of collaborative
                audiovisual performance from a live event to a diaryｰlike experience. a change in pace, space and focus,
                towards non-linear forms and a cozier process.</p>
            <p> o0yu (Yuki) and gonima (Evan Magoni) spent one week as virtual pen pals, sending a single evolving clip
                back and forth, to create seven short diary entries.</p>
            <p>the creation process lead to variations and branches, open pages of a slice-of-dream chapter.</p>
            <p>full experience on desktop – please <strong>explore by moving the mouse</strong> and clicking to open the
                videos, and come back any time: <em>mp4diary.neocities.org</em> :) </p>
        </div>
        <div class="description" id="fr" style="display:none;">
            <p><strong>diary.mp4</strong> transforme le format de la
                performance
                audiovisuelle
                collaborative, passant d'un événement en direct à une expérience semblable à un journal intime. un
                changement de rythme, d'espace et d'orientation, vers des formes non linéaires et un processus plus
                intimiste.</p>
            <p>o0yu (Yuki) et gonima (Evan Magoni) ont passé une semaine à échanger des messages virtuels, s'envoyant un
                seul clip évolutif, afin de créer sept courtes entrées de journal intime.</p>
            <p>le processus de création n'a pas abouti à un produit final ou à une performance unique, mais plutôt à des
                variations et des ramifications, des pages ouvertes d'un chapitre de rêve.</p>
            <p>experience complet sur desktop – <strong>explorez en déplaçant la souris</strong> et en cliquant pour
                ouvrir les vidéos, et revenez quand vous le souhaitez : <em>mp4diary.neocities.org</em> :)</p>
        </div>
    </div>

    <!-- TODO default to smaller videos, only load larger if screen height > 480 + some buffer -->
    <!-- TODO actual video elements on mobile? only replace on desktop -->
    <div id="image-layer">
        <div class="image-item">
            <img src="./static/day1.png" data-video="https://mp4diary.netlify.app/static/day1.mov" />
        </div>
        <div class="image-item">
            <img src="./static/day2.png" data-video="https://mp4diary.netlify.app/static/day2.mov" />
        </div>
        <div class="image-item">
            <img src="./static/day3.png" data-video="https://mp4diary.netlify.app/static/day3.mov" />
        </div>
        <div class="image-item description-spacer"><!-- description placeholder -->&nbsp;</div>
        <div class="image-item">
            <img src="./static/day4.png" data-video="https://mp4diary.netlify.app/static/day4.mov" />
        </div>
        <div class="image-item">
            <img src="./static/day5.png" data-video="https://mp4diary.netlify.app/static/day5.mov" />
        </div>
        <div class="image-item">
            <img src="./static/day6.png" data-video="https://mp4diary.netlify.app/static/day6.mov" />
        </div>
        <div class="image-item">
            <img src="./static/day7.png" data-video="https://mp4diary.netlify.app/static/day7.mov" />
        </div>
    </div>

    <script>
        // remember if the user interacted with the page — allows unmuted autoplay later
        window._userHasInteracted = window._userHasInteracted || false;
        (function () {
            function mark() {
                if (window._userHasInteracted) return;
                window._userHasInteracted = true;
                // remove listeners once we have an interaction
                document.removeEventListener('pointerdown', mark);
                document.removeEventListener('keydown', mark);
                document.removeEventListener('touchstart', mark);
            }

            // capture a broad user gesture set
            document.addEventListener('pointerdown', mark, { once: true });
            document.addEventListener('keydown', mark, { once: true });
            document.addEventListener('touchstart', mark, { once: true });
        })();
    </script>

    <!-- TODO only load the below for more recent browsers -->
    <script src="./static/particles.min.js" defer></script>
    <script src="./static/bg.js" defer></script>

    <script>
        // Open a centered popup window and write a simple HTML document with an autoplaying, muted video
        function openCenteredPopup(url, desiredWidth = 1024, desiredHeight = 604) {
            if (!url) return null;

            // calculate the size within available screen
            const w = Math.min(desiredWidth, Math.floor(window.screen.availWidth * 0.92));
            const h = Math.min(desiredHeight, Math.floor(window.screen.availHeight * 0.86));

            // account for multi-screen setups
            const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
            const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;

            const left = dualScreenLeft + Math.floor((window.innerWidth - w) / 2);
            const top = dualScreenTop + Math.floor((window.innerHeight - h) / 2);

            // include 'location=no' (old browsers) and remove toolbar/status where possible.
            // NOTE: modern browsers intentionally keep an address bar for security —
            // this is a best-effort request and may be ignored.
            const features = 'width=' + w + ',height=' + h + ',left=' + left + ',top=' + top + ',resizable=yes,scrollbars=no,location=no,status=no,toolbar=no,menubar=no';

            // open or reuse a named popup window so repeated clicks reuse the same popup
            // (some browsers still show the address bar regardless)
            const win = window.open('', 'video-popup', features);
            if (!win) {
                // popup blocked — fallback to opening video in a new tab
                window.location.href = url;
                return null;
            }

            // Basic markup for the popup — if the user has previously interacted with the page
            // we will try to open unmuted, otherwise start muted to satisfy autoplay policies.
            const shouldStartUnmuted = !!window._userHasInteracted;

            // Basic markup for the popup
            const html = '<!doctype html>' +
                '<html>' +
                '<head>' +
                '<meta charset="utf-8">' +
                '<meta name="viewport" content="width=device-width,initial-scale=1">' +
                '<title>Video</title>' +
                '<style>html,body{height:100%;margin:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center}video{max-width:100%;max-height:100%;box-shadow:0 8px 40px rgba(0,0,0,0.5);}</style>' +
                '</head>' +
                '<body>' +
                '<video id="popupVideo" src="' + url + '" playsinline autoplay ' + (shouldStartUnmuted ? '' : 'muted') + ' controls></video>' +
                '<script>var v=document.getElementById("popupVideo"); if(' + (shouldStartUnmuted ? 'true' : 'false') + '){ v.muted = false; } else { v.muted = true; } v.play && v.play().catch(function(){}); window.addEventListener("beforeunload", function(){ try{v.pause(); }catch(e){} });<\/script>' +
                '</body>' +
                '</html>';

            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
                win.focus();
            } catch (err) {
                // Could fail on cross-origin or other restrictions — fallback
                console.warn('Could not write to popup window — opening raw video URL instead', err);
                win.location.href = url;
            }

            return win;
        }

        (function () {
            try {
                const host = window.location.hostname || '';
                if (host.indexOf('neocities') === -1) {
                    const base = 'https://mp4diary.netlify.app/';
                    document.querySelectorAll('img[data-video]').forEach(img => {
                        const v = img.getAttribute('data-video') || '';
                        // leave absolute URLs alone
                        if (!v || /^https?:\/\//i.test(v)) return;
                        // normalize relative path and hotlink to the netlify host
                        const normalized = v.replace(/^https:\/\/mp4diary\.netlify\.app\//, './');
                        const finalUrl = base + normalized;
                        img.setAttribute('data-video', finalUrl);
                        // ensure dataset reflects change immediately
                        img.dataset.video = finalUrl;
                    });
                }
            } catch (err) {
            }
        })();

        // Attach click handlers to images with data-video set
        document.addEventListener('click', function (e) {
            const el = e.target && e.target.closest && e.target.closest('img[data-video]');
            if (!el) return;
            e.preventDefault();
            const videoUrl = el.dataset && el.dataset.video;
            openCenteredPopup(videoUrl);
        }, { capture: true });
    </script>

    <script>
        (function () {
            if (!window.matchMedia || !window.matchMedia("(hover: hover)")) return;
            window.FlashlightConfig = window.FlashlightConfig || { radius: 260, enabled: true };

            const container = document.getElementById('image-layer');
            if (!container) return;

            // treat each grid cell (.image-item) as a masked cell — child images move inside
            const items = Array.from(container.querySelectorAll('.image-item'));
            items.forEach(item => {
                const img = item.querySelector && item.querySelector('img');
                if (!img) return; // skip non-image cells (eg description)

                // apply mask state to the cell; image offsets live on the image
                item.classList.add('masked');
                // start hidden until user moves over the cell
                item.classList.add('hidden');
                item.style.setProperty('--fr', window.FlashlightConfig.radius + 'px');

                // assign a small random offset for the inner image so the grid looks staggered
                const ox = Math.round((Math.random() - 0.5) * 80); // -40..40
                const oy = Math.round((Math.random() - 0.5) * 60); // -30..30
                img.style.setProperty('--ox', ox + 'px');
                img.style.setProperty('--oy', oy + 'px');
            });


            // Throttle pointer/touch handling by batching events and processing via requestAnimationFrame
            let rafScheduled = false;
            let pendingPos = { x: 0, y: 0 };

            function scheduleProcess(clientX, clientY) {
                pendingPos.x = clientX;
                pendingPos.y = clientY;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        rafScheduled = false;
                        processPosition(pendingPos.x, pendingPos.y);
                    });
                }
            }

            function onPointerMove(e) {
                if (!window.FlashlightConfig.enabled) return;
                scheduleProcess(e.clientX, e.clientY);
            }

            function onTouchMove(e) {
                const t = e.touches && e.touches[0];
                if (!t || !window.FlashlightConfig.enabled) return;
                scheduleProcess(t.clientX, t.clientY);
            }

            function processPosition(clientX, clientY) {
                // update each image based on the latest batched cursor position
                for (const item of items) {
                    const r = item.getBoundingClientRect();
                    const inside = clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
                    if (inside) {
                        const cx = Math.round(clientX - r.left);
                        const cy = Math.round(clientY - r.top);
                        item.classList.remove('hidden');
                        item.style.setProperty('--fx', cx + 'px');
                        item.style.setProperty('--fy', cy + 'px');
                    } else {
                        item.classList.add('hidden');
                    }
                }
            }

            // wire events
            document.addEventListener('pointermove', onPointerMove, { passive: true });
            document.addEventListener('touchmove', onTouchMove, { passive: true });

            // expose API
            window.Flashlight = { enable, disable, setRadius };
        })();
    </script>
</body>

</html>