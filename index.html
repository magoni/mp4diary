<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diary.mp4</title>
    <style>
        body {
            position: relative;
            background: #fff;
            overflow: hidden;
            padding: 16px;
        }

        .description p {
            margin-top: 0;
        }

        #language-select {
            margin-bottom: 16px;
        }

        .description-container {
            position: fixed;
            right: 16px;
            top: 16px;
            max-width: 600px;
            margin: 0 auto 48px auto;
            padding: 0 16px;
            z-index: 3;
            text-align: right;
        }

        .description {
            /* max-width: 600px; */
            /* margin: 24px auto; */
            padding: 0;
            /* font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
                sans-serif; */
            font-family: Verdana, Geneva, Tahoma, sans-serif;
            font-size: 16px;
            line-height: 1.5;
            color: #222;
        }

        video {
            position: absolute;
            width: 300px;
        }

        /* halo background */
        #halo-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .halo {
            position: absolute;
            border-radius: 50%;
            /* darker particles use a slightly tighter blur */
            filter: blur(6px);
            transform: translate3d(0, 0, 0);
            /* fallback/base opacity for non-JS or initial paint */
            opacity: 1.0;
            /* on white background a multiply blend gives dark glows */
            mix-blend-mode: multiply;
            will-change: transform, opacity;
        }

        /* image layer container */
        #image-layer {
            position: fixed;
            inset: 0;
            z-index: 2;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            grid-auto-rows: minmax(280px, 1fr);
            gap: 36px;
            align-items: center;
            justify-items: center;
            padding: 48px;
            box-sizing: border-box;
        }

        /* per-image mask: hide image except for a circular, centered area at --fx/--fy */
        img.masked {
            -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            mask-image: radial-gradient(circle var(--fr, 160px) at var(--fx, 50%) var(--fy, 50%), rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            transition: -webkit-mask-position 120ms linear, mask-position 120ms linear;
            position: relative;
            /* allow transforms to move the asset inside the grid cell */
            transform: translate(var(--ox, 0px), var(--oy, 0px));
            transition: transform 220ms ease, -webkit-mask-position 120ms linear, mask-position 120ms linear;
            /* make images fill their grid cell */
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* helper: when an image is hidden (not under cursor), push the center off-screen so it becomes invisible */
        img.masked.hidden {
            -webkit-mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
            mask-image: radial-gradient(circle var(--fr, 160px) at -9999px -9999px, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 70%);
        }

        /* pulse to hint presence — temporarily reveal the center and scale briefly */
        img.masked.pulse {
            animation: pulseReveal var(--pulse-duration, 1.2s) ease-in-out both;
        }

        @keyframes pulseReveal {
            0% {
                transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(0.95);
                opacity: 0.0;
            }

            15% {
                opacity: 1.0;
                transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.03);
            }

            50% {
                transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.06);
            }

            85% {
                opacity: 0.96;
                transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.02);
            }

            100% {
                transform: translate(var(--ox, 0px), var(--oy, 0px)) scale(1.0);
                opacity: 0.0;
            }
        }
    </style>
</head>

<body bgcolor="#ffffff">
    <div id="halo-container" aria-hidden="true"></div>

    <div class="description-container">
        <select id="language-select" onchange="
        {
            const enDesc = document.getElementById('en');
            const frDesc = document.getElementById('fr');
            if(this.value==='en'){
                enDesc.style.display='block';
                frDesc.style.display='none';
            } else if(this.value==='fr'){
                enDesc.style.display='none';
                frDesc.style.display='block';
            }
        }">
            <option value="en" selected>English</option>
            <option value="fr">Français</option>
        </select>
        <div class="description" id="en">
            <p>with <strong>diary.mp4</strong>, o0yu (Yuki) and gonima (Evan Magoni) shift the format of collaborative
                audiovisual performance from a live event to a diaryｰlike experience. a change in pace, space and focus,
                towards non-linear forms and a cozier process.</p>
            <p>the artists met over a warm meal and spent one week as virtual pen pals, sending a single evolving clip
                back and forth, to create seven short diary entries.</p>
            <p>for the installation, a low table on a rug and cushions lower the viewer's gaze and pace.</p>
            <p>the creation process lead to variations and branches, open pages of a slice-of-dream chapter.</p>
            <p><strong>please explore</strong> by moving the mouse and clicking to open the videos, and come back any
                time:
                <em>mp4diary.neocities.org</em> :)
            </p>
        </div>
        <div class="description" id="fr" style="display:none;">
            <p>avec <strong>diary.mp4</strong>, o0yu (Yuki) et gonima (Evan Magoni) transforment le format de la
                performance
                audiovisuelle
                collaborative, passant d'un événement en direct à une expérience semblable à un journal intime. un
                changement de rythme, d'espace et d'orientation, vers des formes non linéaires et un processus plus
                intimiste.</p>
            <p>les artistes se sont rencontrés autour d'un repas chaleureux et ont passé une semaine à échanger des
                messages
                virtuels, s'envoyant un seul clip évolutif, afin de créer sept courtes entrées de journal intime.</p>
            <p>pour l'installation, une table basse sur un tapis, deux coussins et deux écouteurs connectés à un
                ordinateur portable invitent
                le
                spectateur à baisser le regard et à ralentir le rythme.</p>
            <p>Le processus de création n'a pas abouti à un produit final ou à une performance unique, mais plutôt à des
                variations et des ramifications, des pages ouvertes d'un chapitre de rêve.</p>
            <p>explorez en déplaçant la souris et en cliquant pour ouvrir les vidéos, et revenez quand vous le souhaitez
                : <em>mp4diary.neocities.org</em> :)</p>
        </div>
    </div>

    <div id="image-layer">
        <!-- grid items populate below -->
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day1.jpg" data-video="./static/day1.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day2.jpg" data-video="./static/day2.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day3.jpg" data-video="./static/day3.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day4.jpg" data-video="./static/day4.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day5.jpg" data-video="./static/day5.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day6.jpg" data-video="./static/day6.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
        <div class="image-item" style="display:flex;align-items:center;justify-content:center;position:relative;">
            <img src="./static/day7.jpg" data-video="./static/day7.mov"
                style="width:100%;max-width:420px;cursor:pointer;" />
        </div>
    </div>

    <script>
        // remember if the user interacted with the page — allows unmuted autoplay later
        window._userHasInteracted = window._userHasInteracted || false;
        (function () {
            function mark() {
                if (window._userHasInteracted) return;
                window._userHasInteracted = true;
                // remove listeners once we have an interaction
                document.removeEventListener('pointerdown', mark);
                document.removeEventListener('keydown', mark);
                document.removeEventListener('touchstart', mark);
            }

            // capture a broad user gesture set
            document.addEventListener('pointerdown', mark, { once: true });
            document.addEventListener('keydown', mark, { once: true });
            document.addEventListener('touchstart', mark, { once: true });
        })();
    </script>

    <script src="./static/particles.min.js" defer></script>
    <script src="./static/halo.js" defer></script>

    <script>
        // Open a centered popup window and write a simple HTML document with an autoplaying, muted video
        function openCenteredPopup(url, desiredWidth = 960, desiredHeight = 604) {
            if (!url) return null;

            // calculate the size within available screen
            const w = Math.min(desiredWidth, Math.floor(window.screen.availWidth * 0.92));
            const h = Math.min(desiredHeight, Math.floor(window.screen.availHeight * 0.86));

            // account for multi-screen setups
            const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
            const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;

            const left = dualScreenLeft + Math.floor((window.innerWidth - w) / 2);
            const top = dualScreenTop + Math.floor((window.innerHeight - h) / 2);

            // include 'location=no' (old browsers) and remove toolbar/status where possible.
            // NOTE: modern browsers intentionally keep an address bar for security —
            // this is a best-effort request and may be ignored.
            const features = 'width=' + w + ',height=' + h + ',left=' + left + ',top=' + top + ',resizable=yes,scrollbars=no,location=no,status=no,toolbar=no,menubar=no';

            // open or reuse a named popup window so repeated clicks reuse the same popup
            // (some browsers still show the address bar regardless)
            const win = window.open('', 'video-popup', features);
            if (!win) {
                // popup blocked — fallback to opening video in a new tab
                window.location.href = url;
                return null;
            }

            // Basic markup for the popup — if the user has previously interacted with the page
            // we will try to open unmuted, otherwise start muted to satisfy autoplay policies.
            const shouldStartUnmuted = !!window._userHasInteracted;

            // Basic markup for the popup
            const html = '<!doctype html>' +
                '<html>' +
                '<head>' +
                '<meta charset="utf-8">' +
                '<meta name="viewport" content="width=device-width,initial-scale=1">' +
                '<title>Video</title>' +
                '<style>html,body{height:100%;margin:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center}video{max-width:100%;max-height:100%;box-shadow:0 8px 40px rgba(0,0,0,0.5);}</style>' +
                '</head>' +
                '<body>' +
                '<video id="popupVideo" src="' + url + '" playsinline autoplay ' + (shouldStartUnmuted ? '' : 'muted') + ' controls></video>' +
                '<script>var v=document.getElementById("popupVideo"); if(' + (shouldStartUnmuted ? 'true' : 'false') + '){ v.muted = false; } else { v.muted = true; } v.play && v.play().catch(function(){}); window.addEventListener("beforeunload", function(){ try{v.pause(); }catch(e){} });<\/script>' +
                '</body>' +
                '</html>';

            try {
                win.document.open();
                win.document.write(html);
                win.document.close();
                win.focus();
            } catch (err) {
                // Could fail on cross-origin or other restrictions — fallback
                console.warn('Could not write to popup window — opening raw video URL instead', err);
                win.location.href = url;
            }

            return win;
        }

        // If we're hosted on a neocities domain, hotlink videos from the public netlify site
        (function () {
            try {
                const host = window.location.hostname || '';
                if (host.indexOf('neocities') !== -1) {
                    const base = 'https://mp4diary.netlify.app/';
                    document.querySelectorAll('img[data-video]').forEach(img => {
                        const v = img.getAttribute('data-video') || '';
                        // leave absolute URLs alone
                        if (!v || /^https?:\/\//i.test(v)) return;
                        // normalize relative path and hotlink to the netlify host
                        const normalized = v.replace(/^\.\//, '').replace(/^\//, '');
                        const finalUrl = base + normalized;
                        img.setAttribute('data-video', finalUrl);
                        // ensure dataset reflects change immediately
                        img.dataset.video = finalUrl;
                    });
                }
            } catch (err) {
            }
        })();

        // Attach click handlers to images with data-video set
        document.addEventListener('click', function (e) {
            const el = e.target && e.target.closest && e.target.closest('img[data-video]');
            if (!el) return;
            e.preventDefault();
            const videoUrl = el.dataset && el.dataset.video;
            // open popup at desired, fixed size: 960x604 (still constrained by available screen)
            openCenteredPopup(videoUrl, 960, 604);
        }, { capture: true });
    </script>

    <script>
        (function () {
            window.FlashlightConfig = window.FlashlightConfig || { radius: 260, enabled: true };

            const container = document.getElementById('image-layer');
            if (!container) return;

            // all images in the image-layer are masked
            const images = Array.from(container.querySelectorAll('img'));
            images.forEach(img => {
                img.classList.add('masked');
                // start hidden until user moves over an image
                img.classList.add('hidden');
                img.style.setProperty('--fr', window.FlashlightConfig.radius + 'px');

                // assign a small random offset so the grid looks staggered
                const ox = Math.round((Math.random() - 0.5) * 80); // -40..40
                const oy = Math.round((Math.random() - 0.5) * 60); // -30..30
                img.style.setProperty('--ox', ox + 'px');
                img.style.setProperty('--oy', oy + 'px');
            });

            // pulsing discovery: occasionally reveal a hidden masked image to hint presence
            window.FlashlightPulseConfig = window.FlashlightPulseConfig || { enabled: true, minDelay: 3000, maxDelay: 9000, duration: 5000 };

            let pulseTimer = null;

            function pickRandomHiddenImage() {
                const hidden = images.filter(i => i.classList.contains('hidden'));
                if (!hidden.length) return null;
                // prefer images not pulsed recently
                const idx = Math.floor(Math.random() * hidden.length);
                return hidden[idx];
            }

            function pulseImage(img) {
                if (!img) return;
                // don't pulse if pointer currently inside (user already discovered it)
                const rect = img.getBoundingClientRect();
                // center the pulse at the image center
                const cx = Math.round(rect.width / 2);
                const cy = Math.round(rect.height / 2);
                img.style.setProperty('--fx', cx + 'px');
                img.style.setProperty('--fy', cy + 'px');

                // show briefly
                img.classList.remove('hidden');
                img.classList.add('pulse');

                // remove pulse state after duration
                setTimeout(() => {
                    img.classList.remove('pulse');
                    // if still enabled, hide again
                    if (window.FlashlightConfig && window.FlashlightConfig.enabled) img.classList.add('hidden');
                }, window.FlashlightPulseConfig.duration || 1000);
            }

            function scheduleNextPulse() {
                if (!window.FlashlightPulseConfig.enabled) return;
                const delay = window.FlashlightPulseConfig.minDelay + Math.random() * (window.FlashlightPulseConfig.maxDelay - window.FlashlightPulseConfig.minDelay);
                pulseTimer = setTimeout(() => {
                    const img = pickRandomHiddenImage();
                    if (img) pulseImage(img);
                    scheduleNextPulse();
                }, delay);
            }

            // start pulsing loop
            if (window.FlashlightPulseConfig.enabled) scheduleNextPulse();

            function setRadius(r) {
                images.forEach(i => i.style.setProperty('--fr', r + 'px'));
            }

            function enable() {
                window.FlashlightConfig.enabled = true;
                // keep them hidden until pointer moves into an image
                images.forEach(i => i.classList.add('hidden'));
            }

            function disable() {
                window.FlashlightConfig.enabled = false;
                // remove masking so images display normally
                images.forEach(i => i.classList.remove('masked', 'hidden'));
            }


            // Throttle pointer/touch handling by batching events and processing via requestAnimationFrame
            let rafScheduled = false;
            let pendingPos = { x: 0, y: 0 };

            function scheduleProcess(clientX, clientY) {
                pendingPos.x = clientX;
                pendingPos.y = clientY;
                if (!rafScheduled) {
                    rafScheduled = true;
                    requestAnimationFrame(() => {
                        rafScheduled = false;
                        processPosition(pendingPos.x, pendingPos.y);
                    });
                }
            }

            function onPointerMove(e) {
                if (!window.FlashlightConfig.enabled) return;
                scheduleProcess(e.clientX, e.clientY);
            }

            function onTouchMove(e) {
                const t = e.touches && e.touches[0];
                if (!t || !window.FlashlightConfig.enabled) return;
                scheduleProcess(t.clientX, t.clientY);
            }

            function processPosition(clientX, clientY) {
                // update each image based on the latest batched cursor position
                for (const img of images) {
                    const r = img.getBoundingClientRect();
                    const inside = clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
                    if (inside) {
                        const cx = Math.round(clientX - r.left);
                        const cy = Math.round(clientY - r.top);
                        img.classList.remove('hidden');
                        img.style.setProperty('--fx', cx + 'px');
                        img.style.setProperty('--fy', cy + 'px');
                    } else {
                        img.classList.add('hidden');
                    }
                }
            }

            // wire events
            document.addEventListener('pointermove', onPointerMove, { passive: true });
            document.addEventListener('touchmove', onTouchMove, { passive: true });

            // keyboard toggle: 'f' toggles flashlight
            document.addEventListener('keydown', (e) => {
                if (e.key === 'f' || e.key === 'F') {
                    if (window.FlashlightConfig.enabled) disable(); else enable();
                }
            });

            // expose API
            window.Flashlight = { enable, disable, setRadius };
        })();
    </script>
</body>

</html>